[["index.html", "Introduction to Optimization Preface", " Introduction to Optimization Apurva Nakade 2022-04-04 Preface "],["introduction.html", "Chapter 1 Introduction 1.1 Software tools", " Chapter 1 Introduction The question of optimization is the very general question of deciding when a function \\(f(x_1, \\dots, x_n)\\) attains its maximum or minimum value on a domain \\(D\\) in \\(\\mathbb{R^n}\\). \\[\\begin{align} \\mbox{optimize: } &amp;&amp; f(x_1, \\dots, x_n) &amp; \\\\ \\mbox{subject to: } &amp;&amp; (x_1, \\dots, x_n) &amp;\\in D. \\end{align}\\] These kinds questions show up naturally in every quantitative field. To analyze the question meaningfully, one needs to make some assumptions on \\(f\\) and \\(D\\). In this course, we’ll analyze this question in the special case when the function \\(f\\) is linear and the constraint set \\(D\\) is described using linear inequalities. The study of this problem is called Linear Programming. Despite the simplicity of the Linear Programming setup, or perhaps because of it, LP is one of the most commonly used models for optimization problems. We’ll see how to solve linear programs using the simplex method and go on to analyze the solution sets using duality theory. Linear programs are used for modeling real world problems when prices/costs and constraints are fixed and known beforehand. Even when this is not the case, linear programs are often used to approximate and estimate costs/prices before moving on to more sophisticated techniques. Example 1.1 A bond portfolio manager has $100,000 to allocate to two different bonds; one corporate and one government bond. The corporate bond has a yield of 4%, a maturity of 3 years and an A rating from a rating agency that is translated into a numerical rating of 2 for computational purposes. In contrast, the government bond has a yield of 3%, a maturity of 6 years and rating of Aaa with the corresponding numerical rating of 1 (lower numerical ratings correspond to higher quality bonds). The portfolio manager would like to allocate her funds so that the average rating for the portfolio is no worse than Aa (numerical equivalent 1.5) and average maturity of the portfolio is at most 3.6 years. Any amount not invested in the two bonds will be kept in a cash account that is assumed to earn no interest for simplicity and does not contribute to the average rating or maturity computations. How should the manager allocate her funds between these two bonds to achieve her objective of maximizing the annual yield from this investment? (Cornuéjols, Peña, and Tütüncü 2018) Corporate Government Bounds Yield 4% 3% Maturity 3 6 3.6 Rating A = 2 Aaa = 1 1.5 Fund Allocations ?? ?? 100,000 Solution We can model the above problem as follows: \\[\\begin{equation} \\begin{array}{rrrrrr} \\mbox{maximize:} &amp; 4x &amp; + &amp; 3y \\\\ \\mbox{subject to:} &amp; 3x &amp; + &amp; 6y &amp; \\le &amp; 3.6 \\\\ &amp; 2x &amp; + &amp; y &amp; \\le &amp; 1.5 % &amp; x &amp; + &amp; y &amp; \\le &amp; 1 \\\\ % &amp; x &amp; , &amp; y &amp; \\ge &amp; 0, \\end{array} \\tag{1.1} \\end{equation}\\] where \\(x\\), \\(y\\) are the percentages of corporate and government bonds, respectively, and the objective function when multiplied by $100,000 gives us the net yield. This is an example of a linear program. Note that we cannot subtract inequalities the same way that we can subtract equalities. So to get started, let us assume that both the inequalities are in fact equalities. We can solve the system \\[\\begin{equation} \\begin{array}{rrrrrl} &amp; 3x &amp; + &amp; 6y &amp; = &amp; 3.6 \\\\ &amp; 2x &amp; + &amp; y &amp; = &amp; 1.5 \\end{array} \\end{equation}\\] to obtain \\(x = 0.6\\) and \\(y = 0.3\\). But for this solution \\(x + y = 0.9\\) which is less that 1, meaning that we’re not investing all the available funds! Which raises the question: Is it possible to increase the yield further by not satisfying both of the above equalities and investing all the money instead? This question becomes even more apparent once we realize that the linear program (1.1) is incomplete and the complete linear program that models the problem is as follows: \\[\\begin{equation} \\begin{array}{rrrrrl} \\mbox{maximize:} &amp; 4x &amp; + &amp; 3y \\\\ \\mbox{subject to:} &amp; 3x &amp; + &amp; 6y &amp; \\le &amp; 3.6 \\\\ &amp; 2x &amp; + &amp; y &amp; \\le &amp; 1.5 \\\\ &amp; x &amp; + &amp; y &amp; \\le &amp; 1 \\\\ &amp; x &amp; &amp; &amp; \\ge &amp; 0 \\\\ &amp; &amp; &amp; y &amp; \\ge &amp; 0. \\end{array} \\tag{1.2} \\end{equation}\\] The solution \\((x, y) = (0.6, 0.3)\\) is obtained by changing the first two inequalities to equalities. But this choice is completely arbitrary! We could have switched some other set of inequalities to equalities and obtained a different solution. We’d then need to compare the solutions obtained in each of these cases and find the one that maximizes it. This method becomes unwieldy very fast and we’ll need to develop better ways to solve linear programs. 1.1 Software tools 1.1.1 Graphing calculator Linear programs in two variables can be visualized using a graphing calculator. The constraints in Example 1.1 can be visualized as follows: The feasible set is the quadrilateral formed by the overlap of all three constraint regions. The level sets of the objective function are straight lines of the form \\(4x + 3y = c\\). We can use a graphical calculator to find the largest value of \\(c\\) for which these level sets intersect the feasible region, which turns out to be \\(c = 3.3\\%\\) which gives us a net yield of \\(3.3\\% \\times \\$100,000 = \\$3,300\\). Here is the same picture in Desmos: https://www.desmos.com/calculator/bexwrrcbwx As it turns out, there is no efficient way to implement this method purely algebraically, thereby making it unusable in higher dimensions. 1.1.2 Solver add-in Excel and Google sheets have free, easy-to-use linear program solvers that can be used to solve linear programs and generate sensitivity analysis. Here is a sample solution of Example 1.1 using Solver in Excel: https://1drv.ms/x/s!AnwQOvs0HXuihl3PWf5YQLWsF6qB?e=rddRBy References "],["standard-linear-program.html", "Chapter 2 Standard linear program 2.1 Slack variables 2.2 Basic and non-basic variables", " Chapter 2 Standard linear program A standard linear program is an optimization problem of the following form: \\[\\begin{equation} \\begin{array}{lrrrrrrrrr} \\mbox{maximize: } &amp; c_0 &amp; + &amp; c_1 x_1 &amp; + &amp; \\dots &amp; + &amp; c_n x_n &amp; \\\\ \\mbox{subject to: } &amp; &amp; &amp; a_{11} x_1 &amp; + &amp; \\dots &amp; + &amp; a_{1n} x_n &amp; \\leq &amp; b_1 \\\\ &amp; &amp; &amp; a_{21} x_1 &amp; + &amp; \\dots &amp; + &amp; a_{2n} x_n &amp; \\leq &amp; b_2 \\\\ &amp; &amp; &amp; &amp; &amp; \\vdots &amp; \\\\ &amp; &amp; &amp; a_{m1} x_1 &amp; + &amp; \\dots &amp; + &amp; a_{mn} x_n &amp; \\leq &amp; b_m \\\\ &amp; &amp; &amp; x_1, &amp; x_2, &amp; \\dots &amp;, &amp; x_n &amp; \\geq &amp; 0 \\end{array} \\tag{2.1} \\end{equation}\\] where \\(c_i\\), \\(a_{ij}\\), and \\(b_j\\) are real constants. The variables \\(x_1, \\dots, x_n\\) are called decision variables. The set of tuples \\((x_1, \\dots, x_n)\\) that satisfy all the constraints is called the feasible region. Example 2.1 Equation (1.2) is an example of a standard linear program with 2 decision variables, 3 constraints, and the feasible region being a quadrilateral. Remark. Not every linear program is standard. However, we will see later that every linear program can be standardized and hence it suffices to construct an algorithm for solving standard linear programs. We’ll assume the following two theorems without proof for now: Theorem 2.1 The feasible region of a standard linear program is either empty, or a convex polytope (possibly degenerate or infinite) . The precise definition of a convex polytope is quite complicated. For the purposes of this class, it is sufficient to think of a polytope as a region that has vertices and edges. Theorem 2.2 Every standard linear program attains its optimal solution, if any, at one of the vertices of the feasible region. Note that the above theorem claims neither the existence nor the uniqueness of an optimal solution. All it is saying is that if a maximum objective value exists then it is attained at one of the vertices. It is possible that no optimal value exists or that the optimal value is attained more than one points, possible at a non-vertex. 2.1 Slack variables For each constraint, we introduce a slack variable by subtracting the LHS from the RHS as follows. \\[\\begin{equation} \\begin{array}{lrrrrrrrrr} w_1 &amp; = &amp; b_1 &amp; - &amp; a_{11} x_1 &amp; - &amp; \\dots &amp; - &amp; a_{1n} x_n \\\\ w_2 &amp; = &amp; b_2 &amp; - &amp; a_{21} x_1 &amp; - &amp; \\dots &amp; - &amp; a_{2n} x_n \\\\ &amp; &amp; &amp; &amp; &amp; \\vdots &amp; \\\\ w_m &amp; = &amp; b_m &amp; - &amp; a_{m1} x_1 &amp; - &amp; \\dots &amp; - &amp; a_{mn} x_n \\end{array} \\tag{2.2} \\end{equation}\\] We can think of the slack variable \\(w_i\\) as measuring the “slackness” in the \\(i^{th}\\) constraint. The \\(i^{th}\\) constraint is strictly met exactly when \\(w_i\\) is zero. Using the slack variables, the linear program (2.1) can be succinctly rewritten as: \\[\\begin{equation} w_1, \\dots, w_m, x_1, \\dots, x_n \\geq 0. \\end{equation}\\] Example 2.2 The slack variables for the linear program (1.2) are as follows: \\[\\begin{equation} \\begin{array}{rlllll} w_1 &amp; = &amp; 3.6 &amp; - &amp; 3x &amp; - &amp; 6y \\\\ w_2 &amp; = &amp; 1.5 &amp; - &amp; 2x &amp; - &amp; y \\\\ w_3 &amp; = &amp; 1 &amp; - &amp; x &amp; - &amp; y. \\end{array} \\end{equation}\\] In terms of these slack variables, the constraints can be rewritten as \\(x, y, w_1, w_2, w_3 \\ge 0\\) and the boundaries of the feasible region are given by \\(x = 0, y = 0, w_1 = 0, w_2 = 0, w_3 = 0\\). 2.2 Basic and non-basic variables Each vertex of the feasible region of a standard linear program in \\(n\\) variables is obtained by setting at least \\(n\\) variables (decision or slack) to zero. These variables are called non-basic and the remaining ones are called basic. Example 2.3 For the linear program (1.2), at the origin: the non-basic variables are \\(x, y\\) and the basic variables are \\(w_1, w_2, w_3\\), at the optimal solution: the non-basic variables are \\(w_1, w_2\\) and the basic variables are \\(x, y, w_3\\). Remark. Not every vertex obtained by setting \\(n\\) variables to zero is in the feasible region. For example, the vertex \\(x = 0, w_2 = 0\\) is not the in feasible region of the linear program (1.2). "],["simplex-method.html", "Chapter 3 Simplex method 3.1 Entering and leaving variables 3.2 Dictionaries 3.3 The simplex step 3.4 Stopping conditions", " Chapter 3 Simplex method The Simplex method is an iterative process for finding the optimal solution of a standard linear program. It starts at the some vertex of the feasible region and in each step moves to an adjacent vertex with a higher objective value. The following picture shows one possible run of the simplex algorithm for solving the linear program (1.2). Figure 3.1: A possible run of the simplex algorithm. 3.1 Entering and leaving variables In each step, one non-basic variable enters the set of basic variables and one basic variable leaves the set of basic variables. The table below explains how these sets are getting updated in the sample simplex algorithm run in Figure 3.1. Leaving variable Entering variable Basic variables Non-basic variables Start \\(\\{w_1, w_2, w_3\\}\\) \\(\\{x, y\\}\\) Step 1 \\(w_2\\) \\(x\\) \\(\\{w_1, x, w_3\\}\\) \\(\\{w_2, y\\}\\) Step 2 \\(w_1\\) \\(y\\) \\(\\{y, x, w_3\\}\\) \\(\\{w_2, w_1\\}\\) Our goal at each step is now reduced to figuring out the entering and leaving variables. 3.2 Dictionaries We’ll find the entering and leaving variables using dictionaries. A dictionary is a set of equations describing the objective function and the constraints in terms of the non-basic variables. Example 3.1 Consider (1.2) again. At the origin the non-basic variables are \\(x, y\\) and hence the initial dictionary is: \\[\\begin{equation} \\begin{array}{rlrrrr} \\mbox{objective} &amp; = &amp; 0 &amp; + &amp; 0.04x &amp; + &amp; 0.03y \\\\ w_1 &amp; = &amp; 3.6 &amp; - &amp; 3x &amp; - &amp; 6y \\\\ w_2 &amp; = &amp; 1.5 &amp; - &amp; 2x &amp; - &amp; y \\\\ w_3 &amp; = &amp; 1 &amp; - &amp; x &amp; - &amp; y. \\end{array} \\tag{3.1} \\end{equation}\\] After the first step of the simplex algorithm, the non-basic variables are \\(w_2, y\\). We can write \\(x\\) in terms of \\(w_2\\) to get \\[\\begin{equation} x = 0.75 - 0.5 w_2 - 0.5 y \\end{equation}\\] We can then substitute this into the initial dictionary to get the dictionary after the first step: \\[\\begin{equation} \\begin{array}{rlrrrr} \\mbox{objective} &amp; = &amp; 3 &amp; + &amp; (-2)w_2 &amp; + &amp; y \\\\ w_1 &amp; = &amp; 1.35 &amp; - &amp; (-1.5) w_2 &amp; - &amp; 4.5y \\\\ x &amp; = &amp; 0.75 &amp; - &amp; 0.5 w_2 &amp; - &amp; 0.5y \\\\ w_3 &amp; = &amp; 0.25 &amp; - &amp; (-0.5) w_2 &amp; - &amp; 0.5y. \\end{array} \\tag{3.2} \\end{equation}\\] Finally, the non-basic variables at the optimal solution are \\(w_1, w_2\\). We can repeat the above process and get the dictionary for the optimal solution: \\[\\begin{equation} \\begin{array}{rlrrrr} \\mbox{objective} &amp; = &amp; 3.3 &amp; + &amp; (-5/3)w_2 &amp; + &amp; (-2/9)w_1 \\\\ y &amp; = &amp; 0.3 &amp; - &amp; (-1/3) w_2 &amp; - &amp; 2/9 w_1 \\\\ x &amp; = &amp; 0.6 &amp; - &amp; 2/3 w_2 &amp; - &amp; (-1/9) w_1 \\\\ w_3 &amp; = &amp; 0.9 &amp; - &amp; (-1/3) w_2 &amp; - &amp; (-1/9) w_1. \\end{array} \\tag{3.3} \\end{equation}\\] Remark. From the dictionary, one can extract the set of basic variables and the set of non-basic variables by looking at the variables appearing on the LHS and RHS, respectively. Furthermore, by setting the non-basic variables to 0, we obtain the very useful fact that the values of the basic variables are simply the constants “\\(b_i\\)”, and the value of the objective function is the constant “\\(c_0\\)”. For example, from the final dictionary above, we can immediately see that \\(x = 0.6\\), \\(y = 0.3\\), \\(w_3 = 0.9\\), and the objective value is \\(3.3%\\) (and \\(w_1 = 0\\) and \\(w_2 = 0.3\\)) at the optimal solution. 3.3 The simplex step We’ll make several simplifying assumptions to begin with and then extend the algorithm to handle more complicated cases. To start, we’ll assume that at each vertex of the feasible region exactly \\(n\\) variables are non-basic. Such a linear program is called non-degenerate. Secondly, we’ll assume that out variables and constants are dynamically updated i.e. after each step we rename the variables so that \\(\\{w_1, \\dots, w_m\\}\\) is the set of basic variables, \\(\\{x_1, \\dots, x_n\\}\\) is the set of non-basic variables, \\(c_j\\), \\(b_i\\), and \\(a_{ij}\\) are the constants appearing in the dictionary so that at the start of each step the dictionary is as follows: \\[\\begin{equation} \\begin{array}{rrrrrrrrrr} \\mbox{objective} &amp; = &amp; c_0 &amp; + &amp; c_1x_1 &amp; + &amp; \\dots &amp; + &amp; c_nx_n \\\\ w_1 &amp; = &amp; b_1 &amp; - &amp; a_{11} x_1 &amp; - &amp; \\dots &amp; - &amp; a_{1n} x_n \\\\ w_2 &amp; = &amp; b_2 &amp; - &amp; a_{21} x_1 &amp; - &amp; \\dots &amp; - &amp; a_{2n} x_n \\\\ &amp; &amp; &amp; &amp; &amp; \\vdots &amp; \\\\ w_m &amp; = &amp; b_m &amp; - &amp; a_{m1} x_1 &amp; - &amp; \\dots &amp; - &amp; a_{mn} x_n \\end{array} \\tag{3.4} \\end{equation}\\] 3.3.1 Choosing the entering variable The entering variable can be some \\(x_j\\) which gets increased from 0 to a positive value. Because the objective function has the following expression, \\[\\begin{align} \\mbox{objective} = c_0 + c_1x_1 + \\dots + c_nx_n \\end{align}\\] we can choose the variable \\(x_j\\) to be entering if and only if \\(c_j\\) is positive as increasing such a variable increases the objective value. We can think of the entering variable as determining the direction of the simplex step. Example 3.2 In the dictionary (3.1), the objective function is \\(4x + 0.03y\\). Hence, both \\(x\\) and \\(y\\) can be chosen as the entering variables. Geometrically, we can see that there are two different paths going from the origin to the optimal solution. In the dictionary (3.2), the objective function is \\(3 + (-2)w_2 + y\\). Hence, only \\(y\\) can be the entering variable. In dictionary (3.3), the objective function is \\(3.3 + (-5/3)w_2 + (-2/9)w_1\\). Hence, there cannot be any entering variable. 3.3.2 Choosing the leaving variable Suppose \\(x_j\\) is the chosen entering variable. Then instead of choosing the leaving variable directly from among the basic variables, we instead increase the largest value that the variable \\(x_j\\) can be increased to. We can think of finding the leaving variable as determining how far we can move in the direction of the simplex step without leaving the feasible region. As \\(x_j\\) increases \\(w_i\\) will decrease exactly when \\(a_{ij} &gt; 0\\). Because we want all the variables to be non-negative, we must always have \\(w_i = b_i - a_{ij} x_j \\ge 0\\). But this condition must hold true for all such \\(w_i\\). Hence, we get that \\(w_i\\) will be the leaving variable if \\[\\begin{align} i = {\\arg \\min} _{a_{ij} &gt; 0} \\dfrac{b_i}{a_{ij}} \\end{align}\\] In this case, after the simplex step \\(w_i \\to 0\\) and \\(x_j \\to {\\min} _{a_{ij} &gt; 0} \\dfrac{b_i}{a_{ij}}\\). Example 3.3 In the dictionary (3.1), if we choose \\(x\\) to be our entering variable then we need to get the following ratios to compare \\(i\\) \\(a_{ij}\\) \\(b_i\\) \\(b_i/a_{ij}\\) 1 3 3.6 1.2 2 2 1.5 0.75 3 1 1 1 We can see that the smallest ratio is obtained for \\(w_2\\) hence it is the only possible candidate for the leaving variable. 3.3.3 Tableau Once we have found the entering and leaving variables \\(x_j\\) and \\(w_i\\), we rewrite \\(x_j\\) in terms of \\(w_i\\) and the other non-basic variables to create the updated dictionary as in Example 3.1. This process can get extremely tedious to perform “by hand”. Instead, we introduce tableau to simplify the process. To begin we rewrite the constraints in the dictionary with all the variables on the LHS and all the constants on the RHS: \\[\\begin{equation} \\begin{array}{rrrrrrrrrr} a_{11} x_1 &amp; + &amp; \\dots &amp; + &amp; a_{1n} x_n &amp; + &amp; w_1 &amp; &amp; &amp; &amp; &amp; &amp; = &amp; b_1\\\\ a_{21} x_1 &amp; + &amp; \\dots &amp; + &amp; a_{2n} x_n &amp; &amp; &amp; + &amp; w_2 &amp; &amp; &amp; &amp; = &amp; b_2\\\\ &amp; &amp; &amp; &amp; &amp; \\vdots &amp; \\\\ a_{m1} x_1 &amp; + &amp; \\dots &amp; + &amp; a_{mn} x_n &amp; &amp; &amp; &amp; &amp; &amp; + &amp; w_m &amp; = &amp; b_m\\\\ \\end{array} \\end{equation}\\] This can then be encoded using the following augmented matrix: \\[\\begin{equation} \\begin{array}{rrrrrrrrrrr|r} a_{11} &amp; &amp; \\dots &amp; &amp; a_{1n} &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp;b_1\\\\ a_{21} &amp; &amp; \\dots &amp; &amp; a_{2n} &amp; &amp; &amp; 1 &amp; &amp; &amp; &amp;b_2\\\\ &amp; &amp; &amp; &amp; &amp; \\vdots &amp; \\\\ a_{m1} &amp; &amp; \\dots &amp; &amp; a_{mn} &amp; &amp; &amp; &amp; &amp; &amp; 1 &amp;b_m\\\\ \\end{array} \\end{equation}\\] We add back the objective function, but because of a quirk of algebra we need to add the objective function coefficients as follows. \\[\\begin{equation} \\begin{array}{rrrrrrrrrrr|r} c_1 &amp; &amp; \\dots &amp; &amp; c_{n} &amp; 0 &amp; &amp; 0 &amp; \\dots &amp; &amp; 0 &amp;-c_0\\\\ \\hline a_{11} &amp; &amp; \\dots &amp; &amp; a_{1n} &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp;b_1\\\\ a_{21} &amp; &amp; \\dots &amp; &amp; a_{2n} &amp; &amp; &amp; 1 &amp; &amp; &amp; &amp;b_2\\\\ &amp; &amp; &amp; &amp; &amp; \\vdots &amp; \\\\ a_{m1} &amp; &amp; \\dots &amp; &amp; a_{mn} &amp; &amp; &amp; &amp; &amp; &amp; 1 &amp;b_m\\\\ \\end{array} \\end{equation}\\] Every column in this augmented matrix corresponds to the variables \\(w_i\\) and \\(x_j\\). The columns with contain pivots correspond to the basic variables. If \\(x_j\\) is the entering variable and \\(w_i\\) is the leaving variable, then we simply perform elementary row operations and turn the entry \\(a_{ij}\\) into a pivot for its column. Hence, this step is also called the pivot step. Example 3.4 The tableau corresponding to the dictionary (3.1) is as follows: \\[\\begin{align} \\begin{bmatrix} 4 &amp; 3 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 3 &amp; 6 &amp; 1 &amp; 0 &amp; 0 &amp; 3.6 \\\\ \\boxed{2} &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1.5 \\\\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\end{bmatrix} \\end{align}\\] If we choose \\(x\\) as the entering variable and \\(w_2\\) as the leaving variable then we need to pivot about the entry \\(a_{21}\\) using elementary row operations to get the following tableau: \\[\\begin{align} \\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; -2 &amp; 0 &amp; -3 \\\\ 0 &amp; 4.5 &amp; 1 &amp; -1.5 &amp; 0 &amp; 1.35 \\\\ \\boxed{1} &amp; 0.5 &amp; 0 &amp; 0.5 &amp; 0 &amp; 0.75 \\\\ 0 &amp; 0.5 &amp; 0 &amp; -0.5 &amp; 1 &amp; 0.25 \\end{bmatrix} \\end{align}\\] which corresponds to the dictionary (3.2). 3.4 Stopping conditions Once we’ve found the entering and leaving variables, we can update the dictionary using the pivot step and start the process again. However, we might not always be able to find the entering and leaving variables. 3.4.1 No entering variable If no entering variable is found, then the geometry tells us that there is no direction in which the objective value can be increased i.e. we’re at a local maxima. But because the objective function a linear function this local maxima is also an absolute maxima and provides an optimal solution to our linear program. Algebraically, this happens when none of the \\(c_i\\) are positive. 3.4.2 No leaving variable If no leaving variable is found, then the geometry tells us that we can keep increasing the entering variable indefinitely without leaving the feasible region. Such a linear program is called unbounded. An unbounded linear program has no optimal solution as the objective can be made arbitrary large without leaving the feasible region. Algebraically, this happens when none of the \\(a_{ij}\\) are positive. The simplex method about starts at a vertex and tries to find an adjacent vertex with a higher objective value. However, we still need some method of finding one vertex of a feasible region. We also have not proven that the simplex algorithm halts. For example, it is possible for the above algorithm to get stuck in a loop. We’ll see how to answer these questions in the next few chapters. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
